import cscience.datastore

class Sample(dict):
    """
    A Sample is a set of data associated with a specific physical entity
    (for example, a single locus on a sediment core). Data associated with
    that Sample is organized by the source of data (system input or calculated
    via a particular CScience 'run').
    """

    def __init__(self, experiment='input', exp_data={}):
        self[experiment] = exp_data.copy()
        self.ignored = False

    @property
    def name(self):
        return '%s:%d' % (self['input'].get('core', 'Core Unset'), 
                          self['input'].get('depth', 'Depth Unset'))

    def __delitem__(self, key):
        raise NotImplementedError('sample data deletion is a no-no!')




class VirtualSample(object):
    """
    A VirtualSample is a view of a sample with only one run. This allows
    viewing of sample data generated by multiple runs (e.g. 'age') as
    distinct entities. Input data is available under all runs.
    """
    #PERF: this is not a terribly efficient class/abstraction; if it turns out
    #to be a memory or performance bottleneck various elements can be made faster

    def __init__(self, sample, run, core_wide={}):
        self.sample = sample
        self.run = run
        self.core_wide = core_wide
        #Make sure the run specified is a working entry in the sample
        self.sample.setdefault(self.run, {})
        self.dst = cscience.datastore.Datastore()

    def __getitem__(self, key):
        if key == 'run':
            #TODO: would it make life easier if this always returned the actual
            #run object? It might, but some testing is needed to make sure
            #that doesn't break various things....
            return self.run
        try:
            att = self.dst.sample_attributes[key]
        except KeyError:
            pass
        else:
            if att.is_virtual:
                return att.compose_value(self)
        try:
            return self.sample[self.run][key]
        except KeyError:
            try:
                return self.sample['input'][key]
            except KeyError:
                try:
                    return self.core_wide[self.run][key]
                except KeyError:
                    try:
                        return self.core_wide['input'][key]
                    except KeyError:
                        return None
    def __setitem__(self, key, item):
        self.sample[self.run][key] = item
    def __delitem__(self, key):
        del self.sample[self.run][key]

    def __contains__(self, key):
        return key in self.keys()
    def __len__(self):
        return len(self.keys())
    def __iter__(self):
        return iter(self.keys())

    def iteritems(self):
        for key in self.keys():
            yield (key, self[key])
    def itervalues(self):
        for key in self.keys():
            yield self[key]

    def sample_keys(self):
        keys = set(self.sample[self.run].keys())
        keys.update(self.sample['input'].keys())
        return keys

    def keys(self):
        keys = self.sample_keys()
        #now add the things that are core-wide....
        keys.update(self.core_wide[self.run].keys())
        keys.update(self.core_wide['input'].keys())
        return keys

    def setdefault(self, key, value):
        self.sample[self.run].setdefault(key, value)

    def search(self, value, view=None, exact=False):
        if not view:
            view = self.dst.views['All']
        for att in view:
            val = str(self[att] or '')
            if val == value or (not exact and value in val):
                return att
        return None
